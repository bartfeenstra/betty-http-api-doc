#!/usr/bin/env bash

set -Eeuo pipefail

cd "$(dirname "$0")/.."

trap tear_down INT TERM EXIT

working_directory_path=$(mktemp -d)

function tear_down_docker() {
    docker stop betty-test-nginx 1>/dev/null
    docker container rm betty-test-nginx 1>/dev/null
}

function tear_down() {
    tear_down_docker
    rm -r "$working_directory_path"
}

# Lint the shell scripts.
for file in ./bin/*; do
    shellcheck -x "$file"
done

# Test the Python code style.
flake8 --config ./flake8.ini ./betty

# Test the CSS code style.
./node_modules/.bin/stylelint "./**/*.css" "./**/*.sass" "./**/*.scss"

# Test the JS code style.
./node_modules/.bin/eslint "./**/*.js"

# Run unit tests with coverage.
coverage erase
coverage run -m nose2
coverage report -m

# Test the monolingual Nginx configuration.
nginx_working_directory_path="$working_directory_path/nginx"
mkdir "$nginx_working_directory_path"
nginx_output_directory_path="$nginx_working_directory_path/output"
jq --arg OUTPUT_DIRECTORY_PATH "$nginx_output_directory_path" '. + {"output": $OUTPUT_DIRECTORY_PATH}' ./betty/tests/resources/nginx/betty-monolingual.json > "$nginx_working_directory_path/betty.json"
betty -c "$nginx_working_directory_path/betty.json" generate 2>/dev/null
nginx_conf_path="$nginx_output_directory_path/nginx.conf"
nginx_conf=$(cat "$nginx_conf_path")
echo "$nginx_conf" | awk '{if($1 == "root") {print "root /var/www/betty/;"} else {print $0}}' > "$nginx_conf_path"
cat "$nginx_output_directory_path/nginx.conf"
docker run --name betty-test-nginx -d -v "$nginx_conf_path:/etc/nginx/conf.d/betty.conf:ro" -v "$nginx_output_directory_path/www:/var/www/betty:ro" nginx:1 1>/dev/null
nginx_container_address=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' betty-test-nginx)
# Test the front page.
status=$(curl -s -o /dev/null -w "%{http_code}" "$nginx_container_address:80")
test 200 -eq "$status" || echo 'A request to the front page does not return an HTTP 200 response.'
# Test HTTP 404 errors.
status=$(curl -s -o /dev/null -w "%{http_code}" "$nginx_container_address:80/non-existent")
test 404 -eq "$status" || echo 'A request to a non-existent path does not return an HTTP 404 response.'

tear_down_docker

# Test the multilingual Nginx configuration.
jq --arg OUTPUT_DIRECTORY_PATH "$nginx_output_directory_path" '. + {"output": $OUTPUT_DIRECTORY_PATH}' ./betty/tests/resources/nginx/betty-multilingual.json > "$nginx_working_directory_path/betty.json"
betty -c "$nginx_working_directory_path/betty.json" generate 2>/dev/null
nginx_conf_path="$nginx_output_directory_path/nginx.conf"
nginx_conf=$(cat "$nginx_conf_path")
echo "$nginx_conf" | awk '{if($1 == "root") {print "root /var/www/betty/;"} else {print $0}}' > "$nginx_conf_path"
cat "$nginx_output_directory_path/nginx.conf"
docker run --name betty-test-nginx -d -v "$nginx_conf_path:/etc/nginx/conf.d/betty.conf:ro" -v "$nginx_output_directory_path/www:/var/www/betty:ro" nginx:1 1>/dev/null
nginx_container_address=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' betty-test-nginx)
# Test the redirect to the localized front page.
status=$(curl -s -o /dev/null -L -w "%{http_code} %{url_effective}" "$nginx_container_address:80")
test "200 http://$nginx_container_address/en/" == "$status" || echo 'A request to the base URL does not redirect to the localized front page.'
# Test HTTP 404 errors.
status=$(curl -s -o /dev/null -w "%{http_code}" "$nginx_container_address:80/nl/non-existent")
test 404 -eq "$status" || echo 'A request to a non-existent path does not return a localized HTTP 404 response.'